#!/usr/bin/env python3
#this code was generated by an LLM and proof-read, edited and iterated upon by Jonas Korkosh

import os
import glob
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import argparse
import re
import ast

def read_progress_csv(filepath):
    """
    Reads a single progress.csv file, returning a list of mean batch rewards.
    Skips any lines starting with '#', which contain metadata.
    """
    df = pd.read_csv(filepath, comment="#")
    rewards = df["ep_reward_mean"].tolist()
    return rewards

def collect_all_progress_files(directory="."):
    """
    Collects all progress.csv files in the given directory and its subdirectories recursively.
    Returns a list of file paths.
    """
    pattern = os.path.join(directory, "**", "*progress.csv")
    return glob.glob(pattern, recursive=True)

def compute_reward_statistics(reward_arrays):
    """
    Given a list of lists (reward_arrays), where each list contains per-batch reward data
    from one run, compute arrays for:
      - batch indices (x-axis)
      - mean reward
      - standard deviation

    Returns: (batches, means, stds)
    """
    max_len = max(len(arr) for arr in reward_arrays)
    means = []
    stds = []

    for batch_idx in range(max_len):
        batch_rewards = []
        for arr in reward_arrays:
            if batch_idx < len(arr):
                batch_rewards.append(arr[batch_idx])
        if batch_rewards:
            means.append(np.mean(batch_rewards))
            stds.append(np.std(batch_rewards))
        else:
            break

    batches = np.arange(1, len(means) + 1)
    return batches, means, stds

<<<<<<< HEAD
def plot_multiple_configs(dir_label_batches_pairs, append=False, title="Rewards vs. Batches"):
=======
def plot_multiple_configs(dir_label_batches_pairs, append=False, title=None):
>>>>>>> SimOpt
    """
    For each (directory, label) pair:
      1) Collect all progress.csv files
      2) Read the reward data
      3) Compute batches/means/stds
      4) Plot them with a given label
    All on the same figure.
    """
    plt.figure(figsize=(8, 5))
    last_x = 0
    for directory, label, num_batches in dir_label_batches_pairs:
        file_paths = collect_all_progress_files(directory)
        if not file_paths:
            print(f"No progress.csv files found in '{directory}', skipping.")
            continue

        # Gather all runs in this directory into a list of reward arrays
        reward_runs = [read_progress_csv(fp) for fp in file_paths]

        # Compute the statistics
        batches, means, stds = compute_reward_statistics(reward_runs)
        if num_batches:
            batches = batches[:num_batches]
            means = means[:num_batches]
            stds = stds[:num_batches]
        if append:
            batches = np.array(batches) + last_x
        # Plot on the same figure
        plt.plot(batches, means, label=label)
        plt.fill_between(
            batches,
            np.array(means) - np.array(stds),
            np.array(means) + np.array(stds),
            alpha=0.2
        )

        last_x = batches[-1]

    plt.title(title)
    plt.xlabel("Batch Index")
    plt.ylabel("Reward")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

def generate_default_label(dirpath):
    """
    Attempt to parse a directory path of the form:
        /.../logs/hardware/QubeSwingupEnv/1e6/seed-984
    Returning a label like:
        hardware/QubeSwingupEnv/1e6/seed-984
    Falls back to "UnknownRun" if parsing fails.
    """
    label = "UnknownRun"
    parts = dirpath.split("/")
    try:
        logs_idx = parts.index("logs")
        # everything that comes after "logs" is joined into the label
        label = "/".join(parts[logs_idx + 1 :])
    except (ValueError, IndexError):
        pass
    return label

def parse_reward_txt(filepath):
    """
    Parses a reward.txt file to extract the list of 'real_rollouts_rewards'.
    Returns a list of floats. Returns an empty list if not found or error.
    """
    rewards_list = []
    with open(filepath, 'r') as f:
        for line in f:
            if line.startswith("real_rollouts_rewards:"):
                list_str = line.split(":", 1)[1].strip()
                parsed_list = ast.literal_eval(list_str)
                # Ensure it's a list and all elements are numbers
                if isinstance(parsed_list, list) and all(isinstance(r, float) for r in parsed_list):
                    rewards_list = parsed_list
                else:
                    print(f"Warning: Parsed data from 'real_rollouts_rewards' in {filepath} is not a list of numbers. Content: {list_str}")
                break 
    return rewards_list

def collect_simopt_iteration_data(seed_dirs, iter_num, num_batches_limit_per_iter):
    """
    Collects data for a specific SimOpt iteration from multiple seed directories.
    Applies num_batches_limit_per_iter to each progress.csv data.
    returns:
        - all_progress_rewards_for_iter: List of lists of rewards from progress.csv from each seed [[progress_rewards_seed1_iter_num], [progress_rewards_seed2_iter_num], ...]
        - all_end_of_iter_rollout_rewards: List of rewards from reward.txt from each seed:  [[rewardstxt_list_seed1_iternum], [rewardstxt_list_seed2_iter_num], ...]
    """
    all_progress_rewards_for_iter = []
    all_end_of_iter_rollout_rewards = []

    for seed_dir in seed_dirs:
        iter_dir = os.path.join(seed_dir, f"iter-{iter_num}")
        
        progress_csv_path = os.path.join(iter_dir, "progress.csv")
        if os.path.exists(progress_csv_path):
            rewards = read_progress_csv(progress_csv_path)
            if rewards:
                if num_batches_limit_per_iter and num_batches_limit_per_iter > 0:
                    rewards = rewards[:num_batches_limit_per_iter]
                if rewards: # Check again after truncation
                    all_progress_rewards_for_iter.append(rewards)
        else:
            print(f"Info: progress.csv not found in {iter_dir}")

        reward_txt_path = os.path.join(iter_dir, "reward.txt")
        rewards = parse_reward_txt(reward_txt_path) # std_r from reward.txt not directly used for this plot
        if rewards:
            all_end_of_iter_rollout_rewards += rewards #list concatenation
        elif os.path.exists(iter_dir): # Only warn if iter_dir exists but reward.txt is bad/missing
            print(f"Info: mean_reward not found or invalid in {reward_txt_path}")
            
    return {
        "all_progress_rewards_for_iter": all_progress_rewards_for_iter,
        "all_end_of_iter_rollout_rewards": all_end_of_iter_rollout_rewards,
    }

def plot_simopt_experiment(seed_directories, num_simopt_iterations_to_plot, title, num_batches_limit_per_iteration):
    """
    Plots SimOpt experiment results, appending iterations and showing mean/std across seeds.
    """
    plt.figure(figsize=(12, 7))
    current_total_batches_offset = 0
    
    # colors = plt.cm.viridis(np.linspace(0, 0.9, num_simopt_iterations_to_plot))
    prop_cycle = plt.rcParams['axes.prop_cycle']
    colors = [prop_cycle.by_key()['color'][i % len(prop_cycle.by_key()['color'])] for i in range(num_simopt_iterations_to_plot)]

    for i in range(num_simopt_iterations_to_plot):
        print(f"Processing SimOpt iteration {i}...")
        iteration_data = collect_simopt_iteration_data(seed_directories, i, num_batches_limit_per_iteration)
        
        progress_rewards_lists = iteration_data["all_progress_rewards_for_iter"]
        all_end_of_iter_rollout_rewards = iteration_data["all_end_of_iter_rollout_rewards"]

        plot_label_suffix = f"(Iter {i}, {len(progress_rewards_lists)} seeds)" if progress_rewards_lists else f"(Iter {i}, No progress data)"

        if not progress_rewards_lists:
            print(f"  No progress.csv data found for iteration {i} across any seeds. Skipping batch plot segment.")
            # Attempt to plot end-of-iteration point if data exists, but x-pos might be an issue.
            # For now, if no batch data, we can't reliably place the end-of-iter point.
            # A placeholder for x could be added if needed, e.g., current_total_batches_offset += some_default_length
            continue

        batches_iter_segment, means_iter_segment, stds_iter_segment = compute_reward_statistics(progress_rewards_lists)

        if not batches_iter_segment.size:
            print(f"  No valid batch data after statistics for iteration {i}. Skipping batch plot segment.")
            continue

        # Shift x-axis for appending this iteration's segment
        plot_batches_segment = np.array(batches_iter_segment) + current_total_batches_offset
        
        line_color = colors[i % len(colors)]
        
        # Plot mean line and std fill for batch rewards
        plt.plot(plot_batches_segment, means_iter_segment, color=line_color, label=f"Iter {i} Batch Rewards")
        plt.fill_between(
            plot_batches_segment,
            np.array(means_iter_segment) - np.array(stds_iter_segment),
            np.array(means_iter_segment) + np.array(stds_iter_segment),
            alpha=0.2,
            color=line_color
        )
        
        iter_segment_end_x = plot_batches_segment[-1]

        # Plot end-of-iteration aggregate reward point (mean of means from reward.txt, with std of these means)
        if all_end_of_iter_rollout_rewards:
            # Mean of the reported mean_rewards from reward.txt across seeds
            aggregate_mean_at_iter_end = np.mean(all_end_of_iter_rollout_rewards)
            # Std of the reported mean_rewards from reward.txt across seeds
            aggregate_std_at_iter_end = np.std(all_end_of_iter_rollout_rewards)
            
            plt.errorbar(
                x=iter_segment_end_x, 
                y=aggregate_mean_at_iter_end,
                yerr=aggregate_std_at_iter_end,
                fmt='o', 
                color=line_color, 
                capsize=5,
                markersize=8,
                markeredgecolor='black',
                elinewidth=2,
                label=f"Iter {i} Final Reward" # One label per iteration for its final reward point
            )
            print(f"  Iter {i}: Plotted end-of-iteration avg reward {aggregate_mean_at_iter_end:.2f} +/- {aggregate_std_at_iter_end:.2f} at batch {iter_segment_end_x}")
        else:
            print(f"  No reward.txt data found/parsed for iteration {i} to plot aggregate end-of-iteration point.")

        current_total_batches_offset = iter_segment_end_x 

    plt.title(title if title else "SimOpt Experiment: Mean Rewards vs. Batches")
    plt.xlabel("Total Batch Index (Appended Iterations)")
    plt.ylabel("Mean Episode Reward")
    plt.legend(loc='best')
    plt.grid(True)
    plt.tight_layout()
    plt.show()

def main():
    parser = argparse.ArgumentParser(description="Plot rewards from monitor.csv files.")
    parser.add_argument(
        "-d",
        "--directories",
        type=str,
        nargs="+",
        default=["."],
        help="List of directories in which to search for progress.csv files."
    )
    parser.add_argument(
        "-l",
        "--labels",
        type=str,
        nargs="+",
        default=None,
        help="List of labels corresponding to each directory."
    )
    parser.add_argument(
        "-nb",
        "--num-batches",
        type=int,
        nargs="+",
        default=None,
        help="Number of batches to plot for each corresponding directory. If 0, all batches will be plotted."
    )
    parser.add_argument(
        "-a",
        "--append",
        action="store_true",
        default=False,
        help="Append to the end of the existing plot instead of starting at x=0. Runs in the order specified in the directories argument."
    )
    parser.add_argument(
        "-t",
        "--title",
        type=str,
        default="Rewards vs. Batches",
        help="Title of the plot."
    )
<<<<<<< HEAD
=======
    parser.add_argument(
        "-so",
        "--simopt",
        action="store_true",
        default=False,
        help="Use the simopt directory structure to plot the data. Plots iterations consequtively. Looks for reward.txt at the end of each iteration."
    )
    parser.add_argument(
        "-soi",
        "--simopt-iters",
        type=int,
    )
>>>>>>> SimOpt
    args = parser.parse_args()
    
    if args.simopt:
        if args.directories == ["."]:
            print("Error: For --simopt mode, please provide specific seed directories via -d or --directories (e.g., path/to/seed-123 path/to/seed-456).")
            return
        
        simopt_max_batches_per_iter = 0 
        if args.num_batches and args.num_batches[0] > 0: # Check if list exists and first element is > 0
            simopt_max_batches_per_iter = args.num_batches[0]
            print(f"SimOpt mode: Limiting batches per iteration segment to {simopt_max_batches_per_iter}.")
        elif args.num_batches and args.num_batches[0] <=0 : # Check if 0 or negative
             print(f"SimOpt mode: Plotting all available batches per iteration segment (--num-batches set to {args.num_batches[0]}).")
        else: # args.num_batches is None
             print(f"SimOpt mode: Plotting all available batches per iteration segment (default --num-batches).")

        
        plot_simopt_experiment(
            seed_directories=args.directories,
            num_simopt_iterations_to_plot=args.simopt_iters,
            title=args.title, 
            num_batches_limit_per_iteration=simopt_max_batches_per_iter
        )
    else:
        if args.labels is None or len(args.labels) != len(args.directories):
            # Create default labels if not provided or mismatch in length
            labels = [generate_default_label(dirpath) for dirpath in args.directories]
        else:
            labels = args.labels
        if args.num_batches is None or len(args.num_batches) != len(args.directories):
            # Create default num_batches if not provided or mismatch in length
            print("Warning: num_batches length does not match number of directories, setting all to 0")
            num_batches = [0 for _ in range(len(args.directories))]
        else:
            num_batches = args.num_batches

<<<<<<< HEAD
    dir_label_batches_pairs = list(zip(args.directories, labels, num_batches))
    plot_multiple_configs(dir_label_batches_pairs, append=args.append, title=args.title)
=======
        dir_label_batches_pairs = list(zip(args.directories, labels, num_batches))
        plot_multiple_configs(dir_label_batches_pairs, append=args.append, title=args.title)
>>>>>>> SimOpt

if __name__ == "__main__":
    main()

"""
Example command:
python jonas_plot.py --simopt --simopt-iters 4 -d /home/jonas/Masteroppgave/qube-baselines/logs/SimOpt/QubeSwingupEnv/sim2sim_double_mass_12124545/seed-344 /home/jonas/Masteroppgave/qube-baselines/logs/SimOpt/QubeSwingupEnv/sim2sim_double_mass_12124545/seed-781 /home/jonas/Masteroppgave/qube-baselines/logs/SimOpt/QubeSwingupEnv/sim2sim_double_mass_12124545/seed-414 /home/jonas/Masteroppgave/qube-baselines/logs/SimOpt/QubeSwingupEnv/sim2sim_double_mass_12124545/seed-560 --title "SimOpt test - sim2sim with double mass, N=4"

"""